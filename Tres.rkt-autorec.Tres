#| --------------------------------- Inicio de Grafos completos -----------------------------------------
Desarrollado por: Samuel Josue Mila de la Roca Guerra
Cedula: ;31.632.023
Correo: miladelaroca@gmail.com
Fecha de creación: ;27 de diciembre del 2025
|#

#lang racket
; --------------------------------- Estructuras de datos ---------------------------------
(struct nodo (vertice siguiente) #:mutable #:transparent)
(struct grafo (num-vertices lista-adyacencia) #:transparent)

; --------------------------------- Funciones básicas ---------------------------------
(define (crear-grafo vertices)
  (grafo vertices (make-vector vertices '())))

(define (agregar-arista! grafo origen destino)
  (let ([nuevo (nodo destino (vector-ref (grafo-lista-adyacencia grafo) origen))]
        [nuevo2 (nodo origen (vector-ref (grafo-lista-adyacencia grafo) destino))])
    
    (vector-set! (grafo-lista-adyacencia grafo) origen nuevo)
    (vector-set! (grafo-lista-adyacencia grafo) destino nuevo2)))

; --------------------------------- DFS para ciclos ---------------------------------
(define (DFS-ciclo grafo v visitado padre)
  (vector-set! visitado v 1)
  
  (let iterar ([temp (vector-ref (grafo-lista-adyacencia grafo) v)])
    (when (not (null? temp))
      (let ([u (nodo-vertice temp)])
        (cond
          [(= (vector-ref visitado u) 0)
           (when (DFS-ciclo grafo u visitado v)
             (iterar (nodo-siguiente temp)))]
          [(not (= u padre)) #t]
          [else (iterar (nodo-siguiente temp))]))))
  #f)

; --------------------------------- Verificaciones ---------------------------------
(define (es-conexo? grafo)
  (cond
    [(= (grafo-num-vertices grafo) 0) #t]
    [else
     (let ([visitado (make-vector (grafo-num-vertices grafo) 0)])
       (DFS-ciclo grafo 0 visitado -1)
       (for/and ([i (in-range (grafo-num-vertices grafo))])
         (not (= (vector-ref visitado i) 0))))]))

(define (es-arbol? grafo)
  (cond
    [(= (grafo-num-vertices grafo) 0) #f]
    [else
     (let ([visitado (make-vector (grafo-num-vertices grafo) 0)])
       (cond
         [(DFS-ciclo grafo 0 visitado -1) #f]
         [else
          (for/and ([i (in-range (grafo-num-vertices grafo))])
            (not (= (vector-ref visitado i) 0)))]))]))

(define (es-euleriano? grafo)
  (cond
    [(not (es-conexo? grafo)) #f]
    [else
     (for/and ([i (in-range (grafo-num-vertices grafo))])
       (let calcular-grado ([temp (vector-ref (grafo-lista-adyacencia grafo) i)]
                            [grado 0])
         (if (null? temp)
             (even? grado)
             (calcular-grado (nodo-siguiente temp) (+ grado 1)))))]))

(define (es-bipartito? grafo)
  (let ([color (make-vector (grafo-num-vertices grafo) -1)])
    
    (define (verificar-vertice inicio)
      (let ([cola (make-queue)])
        (enqueue! cola inicio)
        (vector-set! color inicio 0)
        
        (let iterar ()
          (when (not (queue-empty? cola))
            (let ([v (dequeue! cola)])
              (let recorrer-adyacentes ([temp (vector-ref (grafo-lista-adyacencia grafo) v)])
                (when (not (null? temp))
                  (let ([u (nodo-vertice temp)])
                    (cond
                      [(= (vector-ref color u) -1)
                       (vector-set! color u (- 1 (vector-ref color v)))
                       (enqueue! cola u)]
                      [(= (vector-ref color u) (vector-ref color v))
                       #f]
                      [else (recorrer-adyacentes (nodo-siguiente temp))]))))
              (iterar)))))
      #t)
    
    (for/and ([inicio (in-range (grafo-num-vertices grafo))])
      (when (= (vector-ref color inicio) -1)
        (verificar-vertice inicio)))
    #t))

; --------------------------------- Lectura de archivos ---------------------------------
(require racket/file)

(define (leer-archivo nombre-archivo)
  (let* ([lineas (file->lines nombre-archivo)]
         [n (string->number (first lineas))])
    
    (when (or (not n) (<= n 0))
      (error "Número de vértices inválido"))
    
    (let ([grafo (crear-grafo n)])
      (for ([linea (in-list (rest lineas))])
        (let* ([valores (string-split linea)]
               [u (string->number (first valores))]
               [v (string->number (second valores))])
          
          (when (and u v (>= u 0) (< u n) (>= v 0) (< v n))
            (agregar-arista! grafo u v)
            (printf "Advertencia: arista inválida (~a, ~a) ignorada\n" u v))))
      grafo)))

; --------------------------------- Función principal ---------------------------------
(define (main)
  (with-handlers ([exn:fail? (λ (e) (displayln (exn-message e)) 1)])
    (let ([grafo (leer-archivo "data.io")])
      (printf "Conexo: ~a\n" (if (es-conexo? grafo) "SI" "NO"))
      (printf "Arbol: ~a\n" (if (es-arbol? grafo) "SI" "NO"))
      (printf "Euleriano: ~a\n" (if (es-euleriano? grafo) "SI" "NO"))
      (printf "Bipartito: ~a\n" (if (es-bipartito? grafo) "SI" "NO"))
      0)))

; Ejecutar el programa
(main)

